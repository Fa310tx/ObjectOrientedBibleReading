using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using Windows.UI.Popups;

namespace PortableClasses
{
	public class Api
	{
		public async static Task<RootObject> GetApiResultsAsync(DateTime begindate, DateTime enddate, string version = "b_kjv")
		{
			string result = null;

			// make the api call
			result = await Helper.GetJsonAsync("http://www.anti-exe.com/api/dailybiblereading?begindate=" + begindate + "&enddate=" + enddate + "&version=" + version);

			RootObject rootobject = null;
			string textfile = "ApiResults.txt";
			// if there is no content
			if (result == null || result.Contains("SQLSTATE") == true)
			{
				// read content from a pre-existing file
				result = await Helper.ReadTextFileAsync(textfile);
				// do something with the results
				// Output to debugger
				Debug.WriteLine("Can't connect to the API." + "\r\n" + "Loading from local cache.");
				// create a popup with the results
				MessageDialog dialog = new MessageDialog("Can't connect to the API." + "\r\n" + "Loading from local cache.");
				await dialog.ShowAsync();
			}
			else
			{
				// write to a cache file
				await Helper.WriteTextFileAsync(textfile, result);
			}

			// if we still don't have any content
			if (result == null)
			{
				// do something with the results
				// Output to debugger
				Debug.WriteLine("Can't load from local cache." + "\r\n" + "Check your internet connection.");
				// create a popup with the results
				MessageDialog dialog = new MessageDialog("Can't load from local cache." + "\r\n" + "Check your internet connection.");
				await dialog.ShowAsync();
			}
			else
			{
				rootobject = JsonConvert.DeserializeObject<RootObject>(result);
			}
			return rootobject;
		}
	}

	// classes for the daily bible reading api json result
	// classes generated by json2csharp (http://json2csharp.com)
	// generated class names were a little odd so I made them more appropriate
	public class Verse
	{
		public int verse { get; set; }
		public string text { get; set; }
	}
	public class Chapter : INotifyPropertyChanged
	{
		public string date { get; set; }
		public string book { get; set; }
		public int chapter { get; set; }
		public List<Verse> verses { get; set; }
		public string version { get; set; }

		public event PropertyChangedEventHandler PropertyChanged;

		// This method is called by the Set accessor of each property.
        // The CallerMemberName attribute that is applied to the optional propertyName
        // parameter causes the property name of the caller to be substituted as an argument.
        public void NotifyPropertyChanged([CallerMemberName] String propertyName = "")
        {
            if (PropertyChanged != null)
            {
                PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
            }
        }
	}
	public class RootObject
	{
		public List<Chapter> chapters { get; set; }
	}
}